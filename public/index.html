<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Mic Stream Test</title>
<style>
body { font-family: sans-serif; padding: 1rem; max-width: 600px; margin: auto; text-align: center; }
button { margin: 0.5rem; padding: 0.5rem 1rem; font-size: 16px; }
#log { text-align: left; background: #111; color: #0f0; padding: 1rem; height: 200px; overflow-y: auto; white-space: pre-wrap; }
</style>
</head>
<body>
<h2>üéôÔ∏è ESP32 Mic Stream Test</h2>
<button id="start">Start Mic Stream</button>
<button id="stop">Stop</button>
<pre id="log"></pre>

<script>
const log = (m) => {
  document.getElementById('log').textContent += m + "\n";
};

let audioContext, processor, micStream, stopped = false;
const STREAM_URL = '/stream?sample_rate=16000';
const POLL_URL = '/transcript';

async function start() {
  stopped = false;
  log("üéß Requesting mic...");
  const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
  audioContext = new AudioContext({ sampleRate: 16000 });
  micStream = audioContext.createMediaStreamSource(stream);
  
  const workletCode = `
    class PCMWorklet extends AudioWorkletProcessor {
      constructor() { super(); this.buf = []; this.lastSend = 0; }
      process(inputs) {
        const input = inputs[0][0];
        if (!input) return true;
        const pcm = new Int16Array(input.length);
        for (let i = 0; i < input.length; i++) {
          let s = Math.max(-1, Math.min(1, input[i]));
          pcm[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
        }
        this.port.postMessage(pcm.buffer);
        return true;
      }
    }
    registerProcessor('pcm-worklet', PCMWorklet);
  `;
  
  const blob = new Blob([workletCode], { type: 'application/javascript' });
  const url = URL.createObjectURL(blob);
  await audioContext.audioWorklet.addModule(url);
  processor = new AudioWorkletNode(audioContext, 'pcm-worklet');
  processor.port.onmessage = async (e) => {
    if (stopped) return;
    try {
      await fetch(STREAM_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/octet-stream' },
        body: e.data
      });
    } catch (err) { log("‚ö†Ô∏è " + err.message); }
  };
  micStream.connect(processor).connect(audioContext.destination);
  log("üé§ Streaming started...");
  pollTranscript();
}

function stop() {
  stopped = true;
  if (audioContext) audioContext.close();
  log("üõë Mic stopped.");
}

async function pollTranscript() {
  if (stopped) return;
  try {
    const res = await fetch(POLL_URL);
    const j = await res.json();
    if (j.ready && j.transcript) {
      log("üó£Ô∏è " + j.transcript);
    }
  } catch (err) {}
  setTimeout(pollTranscript, 1000);
}

document.getElementById('start').onclick = start;
document.getElementById('stop').onclick = stop;
</script>
</body>
</html>
